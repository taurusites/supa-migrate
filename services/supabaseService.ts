// services/supabaseService.ts
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import { SchemaInfo, TableSelection } from "../types";

interface EnumTypeRow {
  type_schema: string;
  type_name:   string;
  labels:      string[];
}

interface FKRow {
  fk_schema:            string;
  fk_name:              string;
  table_schema:         string;
  table_name:           string;
  column_names:         string[];
  foreign_table_schema: string;
  foreign_table_name:   string;
  foreign_column_names: string[];
}

interface ConstraintRow {
  constraint_name: string;
  definition:      string;
}

interface IndexRow {
  indexdef: string;
}

/** dynamic Supabase client */
function getClient(url: string, key: string): SupabaseClient {
  return createClient(url, key, {
    global: { headers: { Accept: "application/json" } },
  });
}

/** 1) List schemas + tables */
export async function listSchemasAndTables(
  url: string,
  key: string
): Promise<SchemaInfo[]> {
  const supa = getClient(url, key);

  // a) schemas
  const { data: scRows, error: scErr } = await supa
    .rpc<{ schema_name: string }>("pg_list_schemas");
  if (scErr) throw scErr;
  const schemas = scRows?.map((r) => r.schema_name) || [];

  // b) tables per schema
  const out: SchemaInfo[] = [];
  for (const schema of schemas) {
    const { data: tbRows, error: tbErr } = await supa
      .rpc<{ table_name: string }>("pg_list_tables", { schemaname: schema });
    if (tbErr) throw tbErr;
    out.push({
      schema,
      tables: tbRows?.map((r) => r.table_name) || [],
    });
  }

  return out;
}

/**
 * 2) Generate full migration SQL:
 *    – ENUMs
 *    – CREATE TABLEs
 *    – PRIMARY/UNIQUE constraints
 *    – INDEXes
 *    – FOREIGN KEYS
 *    – DATA INSERTs (paginated)
 */
export async function generateMigrationSQL(
  url: string,
  key: string,
  selections: TableSelection[]
): Promise<string> {
  const supa = getClient(url, key);
  let sql = "-- Generated by Supabase Migration Tool\n\n";

  // — ENUM types
  {
    const { data: enums, error: eErr } = await supa
      .rpc<EnumTypeRow>("pg_list_enum_types");
    if (eErr) throw eErr;
    if (enums && enums.length) {
      sql += "-- ENUM TYPES\n";
      for (const e of enums) {
        const vals = e.labels.map((l) => `'${l.replace(/'/g, "''")}'`);
        sql += `CREATE TYPE ${e.type_schema}.${e.type_name} AS ENUM (${vals.join(
          ", "
        )});\n`;
      }
      sql += "\n";
    }
  }

  // — Table DDL + constraints + indexes
  for (const sel of selections.filter((s) => s.selected)) {
    const { schema, table } = sel;

    // a) DDL
    {
      const { data: ddlRows, error: dErr } = await supa
        .rpc<{ ddl: string }>("pg_get_tabledef", {
          schemaname: schema,
          tablename:  table,
        });
      if (dErr) throw dErr;
      const create = ddlRows?.[0]?.ddl;
      sql += `-- DDL for ${schema}.${table}\n${create};\n\n`;
    }

    // b) PRIMARY & UNIQUE constraints
    {
      const { data: cons, error: cErr } = await supa
        .rpc<ConstraintRow>("pg_list_constraints", {
          schemaname: schema,
          tablename:  table,
        });
      if (cErr) throw cErr;
      if (cons && cons.length) {
        sql += `-- Constraints for ${schema}.${table}\n`;
        for (const c of cons) {
          // c.definition is e.g. "PRIMARY KEY (id)" or "UNIQUE (col1, col2)"
          sql += `ALTER TABLE ${schema}.${table}\n`
               + `  ADD CONSTRAINT ${c.constraint_name} ${c.definition};\n`;
        }
        sql += "\n";
      }
    }

    // c) INDEXes (non‑constraint)
    {
      const { data: idxs, error: iErr } = await supa
        .rpc<IndexRow>("pg_list_indexes", {
          schemaname: schema,
          tablename:  table,
        });
      if (iErr) throw iErr;
      if (idxs && idxs.length) {
        sql += `-- Indexes for ${schema}.${table}\n`;
        for (const ix of idxs) {
          // ix.indexdef is like "CREATE INDEX … ON schema.table (…)"
          sql += ix.indexdef.trim() + ";\n";
        }
        sql += "\n";
      }
    }
  }

  // — FOREIGN KEYS (all tables at once)
  {
    const { data: fks, error: fkErr } = await supa
      .rpc<FKRow>("pg_list_foreign_keys");
    if (fkErr) throw fkErr;
    if (fks && fks.length) {
      sql += "-- FOREIGN KEY CONSTRAINTS\n";
      for (const fk of fks) {
        const cols  = fk.column_names.join(", ");
        const fcols = fk.foreign_column_names.join(", ");
        sql += `ALTER TABLE ${fk.table_schema}.${fk.table_name}\n`
             + `  ADD CONSTRAINT ${fk.fk_name}\n`
             + `  FOREIGN KEY (${cols})\n`
             + `  REFERENCES ${fk.foreign_table_schema}.${fk.foreign_table_name}(${fcols});\n\n`;
      }
    }
  }

  // — DATA INSERTS
  for (const sel of selections.filter((s) => s.selected)) {
    const { schema, table } = sel;
    const pageSize = 500;
    let offset = 0;

    while (true) {
      const { data: rows, error: rErr } = await supa
        .from(table, { schema })
        .select("*")
        .range(offset, offset + pageSize - 1);
      if (rErr) throw rErr;
      if (!rows || rows.length === 0) break;

      const cols = Object.keys(rows[0]);
      const vals = rows.map((row) => {
        const items = cols.map((c) => {
          const v = (row as any)[c];
          if (v === null) return "NULL";
          if (typeof v === "string") return `'${v.replace(/'/g, "''")}'`;
          return v.toString();
        });
        return `(${items.join(", ")})`;
      });

      sql += `-- Data for ${schema}.${table} OFFSET ${offset}\n`
           + `INSERT INTO ${schema}.${table} (${cols.join(
             ", "
           )}) VALUES\n${vals.join(",\n")};\n\n`;

      if (rows.length < pageSize) break;
      offset += pageSize;
    }
  }

  return sql;
}