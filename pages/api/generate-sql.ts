// pages/api/generate-sql.ts

import type { NextApiRequest, NextApiResponse } from "next";
import { createClient } from "@supabase/supabase-js";
import { Selection } from "../../types";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<string | { error: string }>
) {
  try {
    // 1) creds
    const url = req.headers["x-sb-url"] as string;
    const key = req.headers["x-sb-key"] as string;
    if (!url || !key) throw new Error("Missing credentials");

    // RPC client for enums/tables/functions/triggers
    const rpc = createClient(url,key,{ global:{ headers:{ Accept:"application/json" }} });

    // parse picks
    const { selections } = req.body as { selections: Selection[] };

    // partition by category
    const pick = (cat:string) => selections.filter((s)=>s.category===cat && s.selected);
    const tables    = pick("table");
    const enums     = pick("enum");
    const funcs     = pick("function");
    const triggers  = pick("trigger");
    const indexes   = pick("index");
    const foreignKs = pick("foreignKey");

    let sql = "-- Generated by Supabase Migration Tool\n\n";

    // --- ENUMs ---
    if (enums.length) {
      sql += "-- ENUM TYPES\n";
      for (const e of enums) {
        const { data, error } = await rpc.rpc("pg_list_enum_types");
        if (error) throw error;
        const row = (data as any[]).find((r)=>r.type_schema===e.schema && r.type_name===e.name);
        const vals = (row.labels as string[]).map((l)=>`'${l.replace(/'/g,"''")}'`);
        sql += `CREATE TYPE ${e.schema}.${e.name} AS ENUM (${vals.join(", ")});\n`;
      }
      sql += "\n";
    }

    // --- FUNCTIONs ---
    if (funcs.length) {
      sql += "-- FUNCTIONS\n";
      for (const f of funcs) {
        const { data, error } = await rpc.rpc("pg_get_functiondef", {
          function_schema: f.schema,
          function_name:   f.name,
        });
        if (error) throw error;
        sql += `${(data as any[])[0].def};\n\n`;
      }
    }

    // --- TRIGGERS ---
    if (triggers.length) {
      sql += "-- TRIGGERS\n";
      for (const t of triggers) {
        const { data, error } = await rpc.rpc("pg_get_triggerdef", {
          trigger_schema: t.schema,
          table_name:     t.name.split(".")[0], // name="table.trigger", but our pick name is trigger_name so we stored t.name properly? adjust above
          trigger_name:   t.name,
        });
        if (error) throw error;
        sql += `${(data as any[])[0].def};\n\n`;
      }
    }

    // --- TABLE DDL + DATA ---
    for (const tbl of tables) {
      // DDL
      {
        const { data, error } = await rpc.rpc("pg_get_tabledef", {
          schemaname: tbl.schema,
          tablename:  tbl.name,
        });
        if (error) throw error;
        sql += `-- DDL for ${tbl.schema}.${tbl.name}\n${(data as any[])[0].ddl};\n\n`;
      }
      // Data
      {
        const db = createClient(url,key,{ db:{schema:tbl.schema}, global:{ headers:{Accept:"application/json"} }});
        let offset = 0, page=500;
        while (true) {
          const { data, error } = await db.from(tbl.name).select("*").range(offset,offset+page-1);
          if (error) throw error;
          const rows = data as any[];
          if (!rows.length) break;
          const cols = Object.keys(rows[0]);
          const vals = rows.map(r=>"("+
            cols.map(c=>
              r[c]===null?"NULL":
              typeof r[c]==="object"? `'${JSON.stringify(r[c]).replace(/'/g,"''")}'::jsonb`:
              `'${String(r[c]).replace(/'/g,"''")}'`
            ).join(", ")+")"
          );
          sql += `-- Data for ${tbl.schema}.${tbl.name} OFFSET ${offset}\n`;
          sql += `INSERT INTO ${tbl.schema}.${tbl.name} (${cols.join(", ")}) VALUES\n${vals.join(",\n")};\n\n`;
          if (rows.length<page) break;
          offset+=page;
        }
      }
    }

    // --- CONSTRAINTS ---
    for (const tbl of tables) {
      const { data, error } = await rpc.rpc("pg_list_constraints", {
        schemaname: tbl.schema,
        tablename:  tbl.name,
      });
      if (error) throw error;
      for (const c of data as any[]) {
        sql += `ALTER TABLE ${tbl.schema}.${tbl.name}\n  ADD CONSTRAINT ${c.constraint_name} ${c.definition};\n`;
      }
      sql += "\n";
    }

    // --- INDEXES (skip pkey/indexes matching constraint names) ---
    for (const tbl of tables) {
      // get constraint names
      const rc = await rpc.rpc("pg_list_constraints", {
        schemaname: tbl.schema,
        tablename:  tbl.name,
      });
      if (rc.error) throw rc.error;
      const cNames = (rc.data as any[]).map((r)=>r.constraint_name);

      // get indexes
      const ri = await rpc.rpc("pg_list_indexes", {
        schemaname: tbl.schema,
        tablename:  tbl.name,
      });
      if (ri.error) throw ri.error;
      const idxs = ri.data as Array<{ indexdef:string }>;

      const use = idxs.filter(ix=>{
        const m = ix.indexdef.match(/INDEX\s+("?)([^\s"]+)\1/i);
        const nm = m?.[2]||"";
        return nm && !cNames.includes(nm);
      });

      if (use.length) {
        sql+=`-- Indexes for ${tbl.schema}.${tbl.name}\n`;
        use.forEach(ix=>sql+=ix.indexdef.trim()+";\n");
        sql+="\n";
      }
    }

    // --- FOREIGN KEYS between selected tables ---
    {
      const r = await rpc.rpc("pg_list_foreign_keys");
      if (r.error) throw r.error;
      const fks = r.data as any[];

      const use = fks.filter((fk)=>{
        const left  = `${fk.table_schema}.${fk.table_name}`;
        const right = `${fk.foreign_table_schema}.${fk.foreign_table_name}`;
        return tableSet.has(left) && tableSet.has(right);
      });

      if (use.length) {
        sql+="-- FOREIGN KEY CONSTRAINTS\n";
        use.forEach((fk:any)=>{
          const cols  = fk.column_names.join(", ");
          const fcols = fk.foreign_column_names.join(", ");
          sql+=`ALTER TABLE ${fk.table_schema}.${fk.table_name}\n`+
               `  ADD CONSTRAINT ${fk.fk_name}\n`+
               `  FOREIGN KEY (${cols}) REFERENCES ${fk.foreign_table_schema}.${fk.foreign_table_name}(${fcols});\n\n`;
        });
      }
    }

    res.setHeader("Content-Type","text/plain");
    return res.status(200).send(sql);
  }
  catch(err:any){
    console.error("generate-sql error:",err);
    return res.status(500).send(err.message);
  }
}